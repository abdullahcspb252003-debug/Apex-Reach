<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Apex Reach</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-bg: #FEF1E1;
            --secondary-bg: #BBD691;
            --text-color: #333;
            --platform-color: #2c2c2c;
            --accent-color: #e53935;
            --font-main: 'Rajdhani', sans-serif;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            background-color: var(--primary-bg);
        }

        body {
            font-family: var(--font-main);
            color: var(--text-color);
        }

        .container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            position: relative;
        }

        /* --- Main Menu --- */
        #main-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 2rem;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, var(--secondary-bg) 0%, var(--primary-bg) 100%);
            z-index: 100;
            position: absolute;
            transition: opacity 0.5s ease-out;
        }

        #main-menu h1 {
            font-family: 'Rajdhani', sans-serif;
            font-weight: 700;
            font-size: clamp(3.5rem, 10vw, 6rem);
            margin: 0;
            color: white;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.4);
        }

        .menu-button {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.5rem;
            font-weight: 600;
            padding: 12px 40px;
            margin-top: 1.5rem;
            border-radius: 50px;
            border: 2px solid white;
            background-color: transparent;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .menu-button:hover {
            background-color: white;
            color: var(--text-color);
            transform: translateY(-3px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        .info-sections {
            margin-top: 3rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            max-width: 600px;
        }

        .info-card {
            background-color: rgba(255, 255, 255, 0.7);
            padding: 1.5rem;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .info-card h2 {
            margin-top: 0;
            font-weight: 700;
            border-bottom: 2px solid var(--text-color);
            padding-bottom: 0.5rem;
        }
        
        .credits {
            position: absolute;
            bottom: 20px;
            font-size: 1rem;
            font-weight: 500;
            color: rgba(0, 0, 0, 0.6);
        }

        /* --- Story Screen --- */
        #story-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
            text-align: center;
            padding: 2rem;
        }

        #story-screen p {
            max-width: 500px;
            font-size: 1.5rem;
            line-height: 1.6;
            font-weight: 500;
        }
        
        /* --- Game UI --- */
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.5s ease-in;
        }

        #score-container {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2rem;
            font-size: 1.5em;
            font-weight: 700;
            background-color: rgba(255, 255, 255, 0.5);
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        #score, #high-score{
             font-variant-numeric: tabular-nums;
        }

        #introduction {
            width: 300px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: 600;
            font-size: 1.2em;
            text-align: center;
            transition: opacity 2s;
            color: rgba(0,0,0,0.7);
        }

        #restart {
            width: 150px;
            height: 60px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 30px;
            color: white;
            background-color: var(--accent-color);
            border: none;
            font-weight: 700;
            font-size: 1.2em;
            font-family: var(--font-main);
            display: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        #restart:hover {
            transform: translate(-50%, -52%);
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
        }

        #perfect {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5em;
            font-weight: 700;
            color: var(--accent-color);
            opacity: 0;
            transition: opacity 1s, transform 1s;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .hidden {
            display: none !important;
        }

        .fade-out {
            opacity: 0 !important;
            pointer-events: none;
        }

        .fade-in {
            opacity: 1 !important;
            pointer-events: all;
        }
    </style>
</head>
<body>
    
    <!-- Main Menu -->
    <div id="main-menu">
        <h1>APEX REACH</h1>
        <button id="play-button" class="menu-button">Play</button>
        <div class="info-sections">
            <div class="info-card">
                <h2>How to Play</h2>
                <p><strong>Objective:</strong> Journey as far as you can across the platforms.</p>
                <p><strong>Controls:</strong> Press and hold the mouse button (or tap and hold on screen) to grow a stick. Release to let it fall. Aim carefully to create a bridge to the next platform.</p>
                 <p><strong>Scoring:</strong> Land on a platform for 1 point. Land in the red 'perfect' zone for 2 points!</p>
            </div>
            <div class="info-card">
                <h2>Game Concept</h2>
                <p>Apex Reach is a game of precision, timing, and focus. The core idea is to test your judgment in a calm, minimalist world. It's about finding a rhythm and pushing your own limits to achieve the highest score, one perfect bridge at a time.</p>
            </div>
        </div>
        <div class="credits">Made By Abdullah Bhatti</div>
    </div>
    
    <!-- Intro Story -->
    <div id="story-screen">
        <p>In a world of silent peaks and endless sky, a lone wanderer journeys onward. The path is not given, but created. With focus and will, bridge the gaps and reach for the next apex.</p>
    </div>

    <!-- Game Content -->
    <div id="game-container" class="container">
        <div id="score-container">
            <div id="score-label">SCORE: <span id="score">0</span></div>
            <div id="high-score-label">BEST: <span id="high-score">0</span></div>
        </div>
        <canvas id="game"></canvas>
        <div id="introduction">Hold down to stretch out a stick</div>
        <div id="perfect">PERFECT!</div>
        <button id="restart">RESTART</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- DOM Elements ---
            const mainMenu = document.getElementById('main-menu');
            const playButton = document.getElementById('play-button');
            const storyScreen = document.getElementById('story-screen');
            const gameContainer = document.getElementById('game-container');
            const canvas = document.getElementById('game');
            const ctx = canvas.getContext('2d');
            const introductionElement = document.getElementById('introduction');
            const perfectElement = document.getElementById('perfect');
            const restartButton = document.getElementById('restart');
            const scoreElement = document.getElementById('score');
            const highScoreElement = document.getElementById('high-score');

            // --- JS Prototypes ---
            Array.prototype.last = function () {
                return this[this.length - 1];
            };
            Math.sinus = function (degree) {
                return Math.sin((degree / 180) * Math.PI);
            };

            // --- Game State & Data ---
            let phase = 'menu'; // menu | story | waiting | stretching | turning | walking | transitioning | falling
            let lastTimestamp;
            let heroX, heroY, sceneOffset;
            let platforms = [];
            let sticks = [];
            let trees = [];
            let score = 0;
            let highScore = 0;
            
            // --- Configuration ---
            const platformHeight = 100;
            const heroDistanceFromEdge = 10;
            const paddingX = 100;
            const perfectAreaSize = 10;
            const backgroundSpeedMultiplier = 0.2;
            const stretchingSpeed = 4;
            const turningSpeed = 4;
            const walkingSpeed = 4;
            const transitioningSpeed = 2;
            const fallingSpeed = 2;
            const heroWidth = 17;
            const heroHeight = 30;
            
            // --- Hills config ---
            const hill1BaseHeight = 100;
            const hill1Amplitude = 10;
            const hill1Stretch = 1;
            const hill2BaseHeight = 70;
            const hill2Amplitude = 20;
            const hill2Stretch = 0.5;

            // --- Menu Logic ---
            playButton.addEventListener('click', () => {
                mainMenu.classList.add('fade-out');
                phase = 'story';
                
                setTimeout(() => {
                    storyScreen.classList.add('fade-in');
                }, 500);

                setTimeout(() => {
                    storyScreen.classList.remove('fade-in');
                    gameContainer.classList.add('fade-in');
                    phase = 'waiting';
                    resetGame();
                }, 4000); // Story duration
            });

            // --- Game Initialization ---
            function init() {
                // Set canvas size
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                // Load high score
                highScore = localStorage.getItem('apexReachHighScore') || 0;
                highScoreElement.innerText = highScore;

                // Set initial background
                draw();

                // Add event listeners
                window.addEventListener('mousedown', handleMouseDown);
                window.addEventListener('mouseup', handleMouseUp);
                window.addEventListener('touchstart', handleMouseDown);
                window.addEventListener('touchend', handleMouseUp);
                restartButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    resetGame();
                });
                window.addEventListener('resize', () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    draw();
                });
            }

            function resetGame() {
                phase = 'waiting';
                lastTimestamp = undefined;
                sceneOffset = 0;
                score = 0;

                introductionElement.style.opacity = 1;
                perfectElement.style.opacity = 0;
                restartButton.style.display = 'none';
                scoreElement.innerText = score;
                highScoreElement.innerText = highScore;

                platforms = [{ x: 50, w: 50 }];
                generatePlatform();
                generatePlatform();
                generatePlatform();
                generatePlatform();

                sticks = [{ x: platforms[0].x + platforms[0].w, length: 0, rotation: 0 }];

                trees = [];
                for (let i = 0; i < 10; i++) generateTree();

                heroX = platforms[0].x + platforms[0].w - heroDistanceFromEdge;
                heroY = 0;
                draw();
            }

            // --- Event Handlers ---
            function handleMouseDown(event) {
                if (phase == 'waiting') {
                    event.preventDefault();
                    lastTimestamp = undefined;
                    introductionElement.style.opacity = 0;
                    phase = 'stretching';
                    window.requestAnimationFrame(animate);
                }
            }

            function handleMouseUp(event) {
                if (phase == 'stretching') {
                    event.preventDefault();
                    phase = 'turning';
                }
            }
            
            // --- Game Logic Functions ---
            function generateTree() {
                const minimumGap = 30;
                const maximumGap = 150;
                const lastTree = trees.last();
                let furthestX = lastTree ? lastTree.x : 0;
                const x = furthestX + minimumGap + Math.floor(Math.random() * (maximumGap - minimumGap));
                const treeColors = ['#6D8821', '#8FAC34', '#98B333'];
                const color = treeColors[Math.floor(Math.random() * 3)];
                trees.push({ x, color });
            }

            function generatePlatform() {
                const minimumGap = 40;
                const maximumGap = 200;
                const minimumWidth = 20;
                const maximumWidth = 100;

                const lastPlatform = platforms.last();
                let furthestX = lastPlatform.x + lastPlatform.w;
                const x = furthestX + minimumGap + Math.floor(Math.random() * (maximumGap - minimumGap));
                const w = minimumWidth + Math.floor(Math.random() * (maximumWidth - minimumWidth));
                platforms.push({ x, w });
            }

            function updateHighScore() {
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('apexReachHighScore', highScore);
                    highScoreElement.innerText = highScore;
                }
            }

            // --- Main Game Loop ---
            function animate(timestamp) {
                if (!lastTimestamp) {
                    lastTimestamp = timestamp;
                    window.requestAnimationFrame(animate);
                    return;
                }
                const deltaTime = timestamp - lastTimestamp;

                switch (phase) {
                    case 'waiting': return;
                    case 'stretching':
                        sticks.last().length += deltaTime / stretchingSpeed;
                        break;
                    case 'turning':
                        sticks.last().rotation += deltaTime / turningSpeed;
                        if (sticks.last().rotation > 90) {
                            sticks.last().rotation = 90;
                            const [nextPlatform, perfectHit] = thePlatformTheStickHits();
                            if (nextPlatform) {
                                score += perfectHit ? 2 : 1;
                                scoreElement.innerText = score;
                                if (perfectHit) {
                                    perfectElement.style.opacity = 1;
                                    perfectElement.style.transform = 'translateX(-50%) translateY(-20px)';
                                    setTimeout(() => {
                                        perfectElement.style.opacity = 0;
                                        perfectElement.style.transform = 'translateX(-50%) translateY(0px)';
                                    }, 1000);
                                }
                                generatePlatform();
                                generateTree();
                                generateTree();
                            }
                            phase = 'walking';
                        }
                        break;
                    case 'walking':
                        heroX += deltaTime / walkingSpeed;
                        const [nextPlatform] = thePlatformTheStickHits();
                        if (nextPlatform) {
                            const maxHeroX = nextPlatform.x + nextPlatform.w - heroDistanceFromEdge;
                            if (heroX > maxHeroX) {
                                heroX = maxHeroX;
                                phase = 'transitioning';
                            }
                        } else {
                            const maxHeroX = sticks.last().x + sticks.last().length + heroWidth;
                            if (heroX > maxHeroX) {
                                heroX = maxHeroX;
                                phase = 'falling';
                            }
                        }
                        break;
                    case 'transitioning':
                        sceneOffset += deltaTime / transitioningSpeed;
                        const [nextPlat] = thePlatformTheStickHits();
                        if (sceneOffset > nextPlat.x + nextPlat.w - paddingX) {
                            sticks.push({
                                x: nextPlat.x + nextPlat.w,
                                length: 0,
                                rotation: 0
                            });
                            phase = 'waiting';
                        }
                        break;
                    case 'falling':
                        if (sticks.last().rotation < 180) {
                            sticks.last().rotation += deltaTime / turningSpeed;
                        }
                        heroY += deltaTime / fallingSpeed;
                        if (heroY > canvas.height / 2) {
                            updateHighScore();
                            restartButton.style.display = 'block';
                            return;
                        }
                        break;
                    default:
                        throw new Error('Wrong phase');
                }

                draw();
                lastTimestamp = timestamp;
                window.requestAnimationFrame(animate);
            }

            function thePlatformTheStickHits() {
                const stick = sticks.last();
                if (stick.rotation !== 90) throw new Error(`Stick is ${stick.rotation}Â°`);
                const stickFarX = stick.x + stick.length;

                const platformHit = platforms.find(p => stickFarX > p.x && stickFarX < p.x + p.w);

                if (platformHit) {
                    const perfectStart = platformHit.x + platformHit.w / 2 - perfectAreaSize / 2;
                    const perfectEnd = platformHit.x + platformHit.w / 2 + perfectAreaSize / 2;
                    if (stickFarX > perfectStart && stickFarX < perfectEnd) {
                        return [platformHit, true];
                    }
                }
                return [platformHit, false];
            }
            
            // --- Drawing Functions ---
            function draw() {
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;

                ctx.save();
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                drawBackground();
                
                // Center the main game area
                ctx.translate(
                    (canvasWidth / 2) - paddingX - sceneOffset,
                    (canvasHeight - platformHeight * 2) // Adjust vertical position
                );

                drawPlatforms();
                drawHero();
                drawSticks();

                ctx.restore();
            }

            function drawPlatforms() {
                platforms.forEach(({ x, w }) => {
                    ctx.fillStyle = 'black';
                    ctx.fillRect(x, platformHeight, w, canvas.height);

                    if (sticks.last().x < x) {
                        ctx.fillStyle = 'red';
                        ctx.fillRect(
                            x + w / 2 - perfectAreaSize / 2,
                            platformHeight,
                            perfectAreaSize,
                            perfectAreaSize
                        );
                    }
                });
            }

            function drawHero() {
                ctx.save();
                ctx.fillStyle = 'black';
                ctx.translate(heroX - heroWidth / 2, heroY + platformHeight - heroHeight / 2);

                drawRoundedRect(-heroWidth / 2, -heroHeight / 2, heroWidth, heroHeight - 4, 5);
                const legDistance = 5;
                ctx.beginPath();
                ctx.arc(legDistance, 11.5, 3, 0, Math.PI * 2, false);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(-legDistance, 11.5, 3, 0, Math.PI * 2, false);
                ctx.fill();
                ctx.beginPath();
                ctx.fillStyle = 'white';
                ctx.arc(5, -7, 3, 0, Math.PI * 2, false);
                ctx.fill();
                ctx.fillStyle = 'red';
                ctx.fillRect(-heroWidth / 2 - 1, -12, heroWidth + 2, 4.5);
                ctx.beginPath();
                ctx.moveTo(-9, -14.5);
                ctx.lineTo(-17, -18.5);
                ctx.lineTo(-14, -8.5);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(-10, -10.5);
                ctx.lineTo(-15, -3.5);
                ctx.lineTo(-5, -7);
                ctx.fill();
                ctx.restore();
            }

            function drawRoundedRect(x, y, width, height, radius) {
                ctx.beginPath();
                ctx.moveTo(x, y + radius);
                ctx.lineTo(x, y + height - radius);
                ctx.arcTo(x, y + height, x + radius, y + height, radius);
                ctx.lineTo(x + width - radius, y + height);
                ctx.arcTo(x + width, y + height, x + width, y + height - radius, radius);
                ctx.lineTo(x + width, y + radius);
                ctx.arcTo(x + width, y, x + width - radius, y, radius);
                ctx.lineTo(x + radius, y);
                ctx.arcTo(x, y, x, y + radius, radius);
                ctx.fill();
            }

            function drawSticks() {
                sticks.forEach(stick => {
                    ctx.save();
                    ctx.translate(stick.x, platformHeight);
                    ctx.rotate((Math.PI / 180) * stick.rotation);
                    ctx.beginPath();
                    ctx.lineWidth = 4;
                    ctx.strokeStyle = '#5a3a22';
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -stick.length);
                    ctx.stroke();
                    ctx.restore();
                });
            }

            function drawBackground() {
                var gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#BBD691');
                gradient.addColorStop(1, '#FEF1E1');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                drawHill(hill1BaseHeight, hill1Amplitude, hill1Stretch, '#95C629');
                drawHill(hill2BaseHeight, hill2Amplitude, hill2Stretch, '#659F1C');

                trees.forEach(tree => drawTree(tree.x, tree.color));
            }

            function drawHill(baseHeight, amplitude, stretch, color) {
                ctx.beginPath();
                ctx.moveTo(0, canvas.height);
                ctx.lineTo(0, getHillY(0, baseHeight, amplitude, stretch));
                for (let i = 0; i < canvas.width; i++) {
                    ctx.lineTo(i, getHillY(i, baseHeight, amplitude, stretch));
                }
                ctx.lineTo(canvas.width, canvas.height);
                ctx.fillStyle = color;
                ctx.fill();
            }

            function drawTree(x, color) {
                ctx.save();
                ctx.translate(
                    (-sceneOffset * backgroundSpeedMultiplier + x) * hill1Stretch,
                    getTreeY(x, hill1BaseHeight, hill1Amplitude)
                );
                const treeTrunkHeight = 5;
                const treeTrunkWidth = 2;
                const treeCrownHeight = 25;
                const treeCrownWidth = 10;
                ctx.fillStyle = '#7D833C';
                ctx.fillRect(-treeTrunkWidth / 2, -treeTrunkHeight, treeTrunkWidth, treeTrunkHeight);
                ctx.beginPath();
                ctx.moveTo(-treeCrownWidth / 2, -treeTrunkHeight);
                ctx.lineTo(0, -(treeTrunkHeight + treeCrownHeight));
                ctx.lineTo(treeCrownWidth / 2, -treeTrunkHeight);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.restore();
            }

            function getHillY(windowX, baseHeight, amplitude, stretch) {
                const sineBaseY = canvas.height - baseHeight;
                return Math.sinus((sceneOffset * backgroundSpeedMultiplier + windowX) * stretch) * amplitude + sineBaseY;
            }

            function getTreeY(x, baseHeight, amplitude) {
                const sineBaseY = canvas.height - baseHeight;
                return Math.sinus(x) * amplitude + sineBaseY;
            }

            // --- Start the app ---
            init();
        });
    </script>
</body>
</html>
